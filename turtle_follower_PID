#!/usr/bin/env python3

import rclpy
from rclpy.node import Node 
from turtlesim.srv import Spawn
from turtlesim.srv import SetPen
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from rclpy.executors import MultiThreadedExecutor
from math import sin,cos,tan,pi,sqrt,atan2

class SpawnNode(Node):

    def __init__(self):
        super().__init__('spawn_node')
        self.client = self.create_client(Spawn , 'spawn')
        while not self.client.wait_for_service(timeout_sec=1):
            self.get_logger().warn("waiting for service")
        
        self.request = Spawn.Request()
        self.request.x = 3.0
        self.request.y = 3.0
        self.request.theta = 0.0
        self.request.name = "turtle2"

        self.future = self.client.call_async(self.request)
        self.future.add_done_callback(self.spawn_response_callback)
    
    def spawn_response_callback(self, future):
        try:
            response = future.result()
            self.get_logger().info(f"Turtle spwaned: {response.name}")
            self.set_pen_client = self.create_client(SetPen, '/turtle2/set_pen')
            while not self.set_pen_client.wait_for_service(timeout_sec=1.0):
                self.get_logger().warn('waiting for /turtle2/set_pen service...')
   
            self.set_pen_color()

        except Exception as e:
            self.get_logger().error(f"Service call failed: {e}")

    def set_pen_color(self):
        pen_request = SetPen.Request()
        pen_request.r = 255
        pen_request.g = 125
        pen_request.b = 0
        pen_request.width = 3
        pen_request.off = 0


        future = self.set_pen_client.call_async(pen_request)
        future.add_done_callback(lambda f: self.get_logger().info("Pen color set to orange"))
                                    
class TwistPublisherNode(Node):

    def __init__(self):
        super().__init__('twist_pub2')

        self.latest_pose = None
        self.latest_pose2 = None

        # For PID
        self.linear_error_integral = 0.0
        self.prev_linear_error = 0.0
        self.angular_error_integral = 0.0
        self.prev_angular_error = 0.0

        self.prev_distance =0.0
        self.prev_time = self.get_clock().now()
        self.prev_angle_error = 0.0
            

        self.subscribe_1 = self.create_subscription(Pose, '/turtle1/pose',self.pose_callback,10)
        self.subscribe_2 = self.create_subscription(Pose, '/turtle2/pose',self.pose_callback2,10)
        self.publisher = self.create_publisher(Twist, '/turtle2/cmd_vel',10)
        self.timer = self.create_timer(0.1, self.send_velocity_command2)
        self.get_logger().info("Publisihing velocity")



    def pose_callback(self, msg: Pose):
        self.latest_pose = msg

    def pose_callback2(self, msg: Pose):
        self.latest_pose2 = msg

    def normalize_angle(self, angle):
        while angle > pi:
            angle -= 2*pi
        while angle < -pi:
            angle += 2 * pi
        return angle
    

    def send_velocity_command2(self):
       

        if self.latest_pose is None or self.latest_pose2 is None:
            self.get_logger().warn("Waiting for both turtle poses...")
            return

        msg = Twist()
        turtle1_x = self.latest_pose.x
        turtle1_y = self.latest_pose.y
        turtle1_theta = self.latest_pose.theta 
        turtle2_x = self.latest_pose2.x
        turtle2_y = self.latest_pose2.y
        turtle2_theta = self.latest_pose2.thetA

        dx = turtle1_x - turtle2_x
        dy = turtle1_y - turtle2_y
        dtheta = turtle1_theta - turtle2_theta  #Not using for now

        distance = sqrt(dx**2 + dy**2)
        angle = atan2(dy, dx)
        angle_difference = self.normalize_angle(angle - turtle2_theta)

        if distance < 0.2:
            self.get_logger().info("Close enough to target. Stopping...")
            self.publisher.publish(Twist())  # Send zero velocity
            return
        
        # Calculate errors
        linear_error = distance
        angular_error = angle_difference

        # Integrate errors over time (Integral term)
        self.linear_error_integral += linear_error * self.timer_period
        self.angular_error_integral += angular_error * self.timer_period

        # Calculate rate of change of errors (Derivative term)
        linear_error_derivative = (linear_error - self.prev_linear_error) / self.timer_period
        angular_error_derivative = (angular_error - self.prev_angular_error) / self.timer_period

        # PID gains (tune these)
        Kp_linear = 1.5
        Ki_linear = 0.2
        Kd_linear = 0.05

        Kp_angular = 8.0
        Ki_angular = 0.1
        Kd_angular = 0.1

        # PID formula
        linear_speed = (Kp_linear * linear_error +
                        Ki_linear * self.linear_error_integral +
                        Kd_linear * linear_error_derivative)

        angular_speed = (Kp_angular * angular_error +
                        Ki_angular * self.angular_error_integral +
                        Kd_angular * angular_error_derivative)

        # Clamp speeds
        max_linear_speed = 1.5
        max_angular_speed = 3.0

        linear_speed = max(min(linear_speed, max_linear_speed), -max_linear_speed)
        angular_speed = max(min(angular_speed, max_angular_speed), -max_angular_speed)

        # Save current errors for next derivative calculation
        self.prev_linear_error = linear_error
        self.prev_angular_error = angular_error

        msg.linear.x = linear_speed
        msg.angular.z = angular_speed

        self.publisher.publish(msg)
        
def main(args = None):
    rclpy.init(args = args)

    spawn_node = SpawnNode()
    twist_node2 = TwistPublisherNode()

    executor = MultiThreadedExecutor()
    executor.add_node(spawn_node)
    executor.add_node(twist_node2)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass

    spawn_node.destroy_node()
    twist_node2.destroy_node()
    rclpy.shutdown()

if __name__=='__main__':
    main()
